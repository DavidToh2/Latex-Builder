# Introduction

This document serves to detail the features developed for the Latex Builder server.

- [Introduction](#introduction)
- [Introduction to Express](#introduction-to-express)
	- [Request and Response Format](#request-and-response-format)
- [CORS](#cors)
- [Error Handling](#error-handling)
	- [Local Error Handlers](#local-error-handlers)
	- [Global Error Handlers](#global-error-handlers)
- [Authentication and Login Systems](#authentication-and-login-systems)
	- [Session Storage](#session-storage)
	- [Authentication Check](#authentication-check)
- [Scripting Latex](#scripting-latex)

# Introduction to Express

ExpressJS uses a system of middlewares, which are functions that "pass on control" to other functions. Based on their positions in the codebase, all middleware functions are arranged in a "running sequence/chain" from first to last

When a request is received, it will be passed through the chain of middlewares, from the start all the way to the end. 
- Routes matching the request parameters are triggered and run.
- All `router.use()` middleware is run.

The `next()` callback passes control onto the next triggered middleware.

## Request and Response Format

Requests are formatted using `post.ts`, which implements the functions `post()`, `postJSON()` and `postForm()` in the front-end. All requests are sent using the format
```
request: {
	method,
	headers: {
		content-type: 'text/html' OR 'application/json'
	},
	body: {
		<content here>
	}
}
```
Refer there for details.

Responses should be formatted according to the following specifications:
```
response: {
	function: [what is the purpose of the request/response?],

	// if success
	body: {
		[data here]
	},

	// if error
	error: {
		type: [user error or database error],
		desc: [string describing error]
	}
}
res.json(response)
```

# CORS



# Error Handling

There are four types of errors that the server should be able to catch:

- **Network/Resource Errors**, caused by incorrect requests to unavailable routes, unavailable files/resources, or misconfigured CORS.
  - Incorrect and unavailable routes should normally bypass all the available routes, and be directly caught by the *global error handler*.
  - CORS errors need to be passed to the *global error handler*.
- **Code Errors**, caused by mistakes in the code. These usually cause the server to crash, so should be okay.
- **Database Errors**, caused by unexpected data behaviour (e.g. duplicate users, user not found, misconfigured `json` request/response).
  - These should be passed on as *server errors, and NOT network/resource errors*! Their error responses will need to be implemented separately.
- **User Errors**, caused by illegal user behaviour (e.g. login email has two '@'s, or mistakes in LaTeX).
  - These should be passed on as *user errors, and NOT network/resource errors*! Their error responses will need to be implemented separately.

## Local Error Handlers

Local error handlers are implemented at the bottom of every individual router

## Global Error Handlers

Global error handlers are implemented at the bottom of the `app.js` file.

# Authentication and Login Systems

We use `express-session`, built-in middleware that implements a session management system. We use `connect-mongo` for the SessionStore, which will be attached to our main database.

## Session Storage

The following cookies will be stored in the user's session storage:
```
Session ID: [generated by express-session]
User ID: [sent by server upon successful login]
```

Session data is stored in the server's SessionStore in this format. The session ID is hashed using the secret in our `.env` folder.
```
{ Encrypted Session ID, { Attached Session Data } }
```

The SessionStore is set up in `app.js`.

## Authentication Check

We can access the SessionStore simply by invoking `req.session`. This will fetch our current user's session ID (stored in the user's session data), check it against our SessionStore, then (if present) fetch all other session data.

This allows us to authenticate users simply by checking the SessionStore for session data (i.e. `req.session.uID`) corresponding to their current session ID.
```
db-auth.js:
function isAuthenticated() {
	if (req.session.uID) next()
	else next('route')		// skips to the next route definition
}
```

Routers can use this function as a callback:
```
router.post(route1, isAuthenticated, <function to execute if authenticated>)
router.post(route1, <function to execute if unauthenticated>)
```

[Documentation for `express-session`](https://www.npmjs.com/package/express-session?activeTab=readme)

[Documentation for `connect-mongo`](https://www.npmjs.com/package/connect-mongo)

[How session tokens and session validation work (StackExchange)](https://security.stackexchange.com/questions/255762/is-this-a-right-technique-to-create-and-validate-session-tokens)

[Using `express-session` and MongoDB to manage sessions](https://developer.okta.com/blog/2021/06/07/session-mgmt-node)

# Scripting Latex

Drive. To implement ability to:
- upload .tex and .pdf files
- view .pdf files
- remove files

Latex compiler. To implement ability to:
- collate build into a .tex file, and:
	- export as .tex file
	- compile into .pdf, then export as .pdf. The file will not be saved
	- compile into .pdf, then save both .tex and .pdf in drive